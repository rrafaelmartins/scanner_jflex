/* Parser de MiniJava - Gramática Sintática com AST */
package minijava;

import java_cup.runtime.*;
import minijava.ast.*;
import java.util.ArrayList;
import java.util.List;

/* Código do parser */
parser code {:
    public Program astRoot;
    
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Erro de sintaxe");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" na linha " + s.left);
                if (s.right >= 0)
                    m.append(", coluna " + s.right);
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/* Definição dos terminais (tokens do scanner) */
terminal CLASS, PUBLIC, STATIC, VOID, MAIN, STRING, EXTENDS, RETURN;
terminal INT, BOOLEAN, IF, ELSE, WHILE;
terminal TRUE, FALSE, THIS, NEW, LENGTH;
terminal PRINTLN;
terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal SEMI, COMMA, DOT, ASSIGN;
terminal AND, LESS, PLUS, MINUS, TIMES, NOT;
terminal Integer INTEGER_LITERAL;
terminal String IDENTIFIER;

/* Definição dos não-terminais com tipos */
non terminal Program Program;
non terminal MainClass MainClass;
non terminal List<ClassDecl> ClassDeclList;
non terminal ClassDecl ClassDecl;
non terminal List<VarDecl> VarDeclList;
non terminal VarDecl VarDecl;
non terminal List<MethodDecl> MethodDeclList;
non terminal MethodDecl MethodDecl;
non terminal List<Formal> FormalList, FormalRest;
non terminal Type Type;
non terminal List<Statement> StatementList;
non terminal Statement Statement;
non terminal Exp Exp;
non terminal List<Exp> ExpList, ExpRest;

/* Precedência dos operadores (menor para maior) */
precedence left AND;
precedence left LESS;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT;
precedence left DOT;
precedence left LBRACKET;

/* Gramática */
start with Program;

/* Program -> MainClass ClassDeclList */
Program ::= MainClass:m ClassDeclList:c
            {: 
               RESULT = new Program(m, c);
               parser.astRoot = RESULT;
               System.out.println("\n[ANALISE SINTATICA] Programa MiniJava reconhecido com sucesso!");
            :}
          ;

/* MainClass */
MainClass ::= CLASS IDENTIFIER:name LBRACE 
              PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET IDENTIFIER:args RPAREN 
              LBRACE Statement:s RBRACE 
              RBRACE
              {: 
                 RESULT = new MainClass(name, args, s);
                 System.out.println("[ANALISE SINTATICA] Classe principal '" + name + "' reconhecida");
              :}
            ;

/* ClassDeclList -> ClassDecl* */
ClassDeclList ::= ClassDeclList:list ClassDecl:c
                  {: list.add(c); RESULT = list; :}
                | 
                  {: RESULT = new ArrayList<ClassDecl>(); :}
                ;

/* ClassDecl */
ClassDecl ::= CLASS IDENTIFIER:name LBRACE VarDeclList:vars MethodDeclList:methods RBRACE
              {: 
                 RESULT = new ClassDecl(name, null, vars, methods);
                 System.out.println("[ANALISE SINTATICA] Classe '" + name + "' reconhecida");
              :}
            | CLASS IDENTIFIER:name EXTENDS IDENTIFIER:parent LBRACE VarDeclList:vars MethodDeclList:methods RBRACE
              {: 
                 RESULT = new ClassDecl(name, parent, vars, methods);
                 System.out.println("[ANALISE SINTATICA] Classe '" + name + "' (extends " + parent + ") reconhecida");
              :}
            ;

/* VarDeclList -> VarDecl* */
VarDeclList ::= VarDeclList:list VarDecl:v
                {: list.add(v); RESULT = list; :}
              | 
                {: RESULT = new ArrayList<VarDecl>(); :}
              ;

/* VarDecl -> Type id ; */
VarDecl ::= Type:t IDENTIFIER:name SEMI
            {: RESULT = new VarDecl(t, name); :}
          ;

/* MethodDeclList -> MethodDecl* */
MethodDeclList ::= MethodDeclList:list MethodDecl:m
                   {: list.add(m); RESULT = list; :}
                 | 
                   {: RESULT = new ArrayList<MethodDecl>(); :}
                 ;

/* MethodDecl */
MethodDecl ::= PUBLIC Type:t IDENTIFIER:name LPAREN FormalList:params RPAREN 
               LBRACE VarDeclList:vars StatementList:stmts RETURN Exp:ret SEMI RBRACE
               {: 
                  RESULT = new MethodDecl(t, name, params, vars, stmts, ret);
                  System.out.println("[ANALISE SINTATICA] Metodo '" + name + "' reconhecido");
               :}
             ;

/* FormalList -> Type id FormalRest* | vazio */
FormalList ::= Type:t IDENTIFIER:name FormalRest:rest
               {: 
                  List<Formal> list = new ArrayList<Formal>();
                  list.add(new Formal(t, name));
                  list.addAll(rest);
                  RESULT = list;
               :}
             | 
               {: RESULT = new ArrayList<Formal>(); :}
             ;

/* FormalRest -> , Type id */
FormalRest ::= FormalRest:list COMMA Type:t IDENTIFIER:name
               {: list.add(new Formal(t, name)); RESULT = list; :}
             | 
               {: RESULT = new ArrayList<Formal>(); :}
             ;

/* Type -> int[] | boolean | int | id */
Type ::= INT LBRACKET RBRACKET
         {: RESULT = new IntArrayType(); :}
       | BOOLEAN
         {: RESULT = new BooleanType(); :}
       | INT
         {: RESULT = new IntType(); :}
       | IDENTIFIER:name
         {: RESULT = new IdentifierType(name); :}
       ;

/* StatementList -> Statement* */
StatementList ::= StatementList:list Statement:s
                  {: list.add(s); RESULT = list; :}
                | 
                  {: RESULT = new ArrayList<Statement>(); :}
                ;

/* Statement */
Statement ::= LBRACE StatementList:list RBRACE
              {: RESULT = new BlockStatement(list); :}
            | IF LPAREN Exp:cond RPAREN Statement:s1 ELSE Statement:s2
              {: RESULT = new IfStatement(cond, s1, s2); :}
            | WHILE LPAREN Exp:cond RPAREN Statement:body
              {: RESULT = new WhileStatement(cond, body); :}
            | PRINTLN LPAREN Exp:e RPAREN SEMI
              {: RESULT = new PrintStatement(e); :}
            | IDENTIFIER:name ASSIGN Exp:e SEMI
              {: RESULT = new AssignStatement(name, e); :}
            | IDENTIFIER:name LBRACKET Exp:idx RBRACKET ASSIGN Exp:e SEMI
              {: RESULT = new ArrayAssignStatement(name, idx, e); :}
            ;

/* Exp - Expressões */
Exp ::= Exp:e1 AND Exp:e2
        {: RESULT = new AndExp(e1, e2); :}
      | Exp:e1 LESS Exp:e2
        {: RESULT = new LessThanExp(e1, e2); :}
      | Exp:e1 PLUS Exp:e2
        {: RESULT = new PlusExp(e1, e2); :}
      | Exp:e1 MINUS Exp:e2
        {: RESULT = new MinusExp(e1, e2); :}
      | Exp:e1 TIMES Exp:e2
        {: RESULT = new TimesExp(e1, e2); :}
      | Exp:e1 LBRACKET Exp:e2 RBRACKET
        {: RESULT = new ArrayLookup(e1, e2); :}
      | Exp:e DOT LENGTH
        {: RESULT = new ArrayLength(e); :}
      | Exp:obj DOT IDENTIFIER:method LPAREN ExpList:args RPAREN
        {: RESULT = new Call(obj, method, args); :}
      | INTEGER_LITERAL:value
        {: RESULT = new IntegerLiteral(value); :}
      | TRUE
        {: RESULT = new TrueExp(); :}
      | FALSE
        {: RESULT = new FalseExp(); :}
      | IDENTIFIER:name
        {: RESULT = new IdentifierExp(name); :}
      | THIS
        {: RESULT = new ThisExp(); :}
      | NEW INT LBRACKET Exp:size RBRACKET
        {: RESULT = new NewArrayExp(size); :}
      | NEW IDENTIFIER:name LPAREN RPAREN
        {: RESULT = new NewObjectExp(name); :}
      | NOT Exp:e
        {: RESULT = new NotExp(e); :}
      | LPAREN Exp:e RPAREN
        {: RESULT = e; :}
      ;

/* ExpList -> Exp ExpRest* | vazio */
ExpList ::= Exp:e ExpRest:rest
            {: 
               List<Exp> list = new ArrayList<Exp>();
               list.add(e);
               list.addAll(rest);
               RESULT = list;
            :}
          | 
            {: RESULT = new ArrayList<Exp>(); :}
          ;

/* ExpRest -> , Exp */
ExpRest ::= ExpRest:list COMMA Exp:e
            {: list.add(e); RESULT = list; :}
          | 
            {: RESULT = new ArrayList<Exp>(); :}
          ;
